# Понимание JVM
## ClassLoader'ы
1. Первоначально происходит компиляциия исходных файлов с расширением JvmComprehension.java, 
   c помощью компилятора javac командой __"$javac JvmComprehension.java"__.
2. После компиляции мы получаем JvmComprehension.class который содержит байт-код.
3. Используя команду __"$java JvmComprehension.class"__ виртуальная машина Java первым делом создает системный загрузчик(*System class loader*).
> + Однако системный загрузчик *System class loader* сам является классом. Вот тут и вступает в игру загрузчик классов *Bootstrap class loader*. Это связано с тем, что загрузчик классов *Bootstrap class loader* написан на машинном коде.
> + Это можно проверить если вызвать метод *getClassLoader()* у класса который загружается при помощи загрузчика классов *Bootstrap class loader*, значение выходных данных будет отображаться значением *null*. Это связано с тем, что загрузчик классов bootstrap написан на машинном коде, а не на Java, поэтому он не отображается как класс Java.  
> Например:  
> System.out.println(Object.class.getClassLoader()); --> null  
> System.out.println(Integer.class.getClassLoader()); --> null  
> System.out.println(System.class.getClassLoader()); --> null  
> + Также *Bootstrap class loader* отвечает за загрузку внутренних классов JDK (обычно jt.jar) и другие основные библиотеки расположенные в каталоге $JAVA_HOME/jre/lib 
> + После выполняется загрузка расширений *Platform class loader* (потомок *Bootstrap class loader*). Загружает классы расширений которые по умолчанию находятся в каталоге jre/lib/ext.
> + И только после этого запускается системный загрузчик, который запускает *JvmComprehension.class*-файл нашего главного класса и вызывает статический метод нашего класса, соответствующий объявлению public static void main(String[] argv), или сообщает об ошибке если метода нет.
> + Главный класс приложения всегда загружается системным загрузчиком, он также известен как `application class loader`. Если вызвать внутри класса метод JvmComprehension.class.getClassLoader() и передать его ответ в System.out.println() то в консоли увидим, что класс `JvmComprehension` был загружен ` AppClassLoader` (**jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7**).
> + Первоначально загружается только класс `JvmComprehension`, как только код этого класса обращается к какому-то другому классу (любым способом: вызовом конструктора, обращением к статическому методу или полю), перед поиском нового класса для загрузки, каждый загрузчик делигирует свои полномочия родителю и пытается узнать не был ли загружен нужный класс раньше.
> + По мере выполнения кода, загружаются всё новые и новые классы. Ни один класс не загружается до тех пор, пока в нем не возникнет реальная потребность. Такое поведение заложено в стандартный системный загрузчик.
>> После загрузки класса начинается этап линковки, который делится на три части.
>> 1. Верификация байт-кода. Это статический анализ кода, выполняется один раз для класса. Система проверяет, нет ли ошибок в байт-коде. Например, проверяет корректность инструкций, переполнение стека и совместимость типов переменных.
>> 2. Выделение памяти под статические поля и их инициализация.
>> 3. Разрешение символьных ссылок — JVM подставляет ссылки на другие классы, методы и поля. В большинстве случаев это происходит лениво, то есть при первом обращении к классу.

1. 

public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}