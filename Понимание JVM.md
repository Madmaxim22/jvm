# Понимание JVM
## ClassLoader'ы
![](/resource/jvm0.webp)
1. Первоначально происходит компиляциия исходных файлов с расширением JvmComprehension.java, 
   c помощью компилятора javac командой __"$javac JvmComprehension.java"__.
2. После компиляции мы получаем JvmComprehension.class который содержит байт-код.
3. Используя команду __"$java JvmComprehension.class"__ виртуальная машина Java первым делом создает системный загрузчик(*System class loader*).
> + Однако системный загрузчик *System class loader* сам является классом. Вот тут и вступает в игру загрузчик классов *Bootstrap class loader*. Это связано с тем, что загрузчик классов *Bootstrap class loader* написан на машинном коде.
> + Это можно проверить если вызвать метод *getClassLoader()* у класса который загружается при помощи загрузчика классов *Bootstrap class loader*, значение выходных данных будет отображаться значением *null*. Это связано с тем, что загрузчик классов bootstrap написан на машинном коде, а не на Java, поэтому он не отображается как класс Java.  
> Например:  
> System.out.println(Object.class.getClassLoader()); --> **null**   
> System.out.println(Integer.class.getClassLoader()); --> **null**  
> System.out.println(System.class.getClassLoader()); --> **null**  
> + Также *Bootstrap class loader* отвечает за загрузку внутренних классов JDK (обычно jt.jar) и другие основные библиотеки расположенные в каталоге $JAVA_HOME/jre/lib 
> + После выполняется загрузка расширений *Platform class loader* (потомок *Bootstrap class loader*). Загружает классы расширений которые по умолчанию находятся в каталоге jre/lib/ext.
> + И только после этого запускается системный загрузчик, который запускает *JvmComprehension* класс и вызывает статический метод этого класса, соответствующий объявлению public static void main(String[] argv), или сообщает об ошибке если метода нет.
> + Главный класс приложения всегда загружается системным загрузчиком, он также известен как *application class loader*. Если вызвать внутри класса метод *JvmComprehension.class.getClassLoader()* и передать его ответ в *System.out.println()*, то в консоли увидим, что класс *JvmComprehension* был загружен *AppClassLoader* (**jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7**).  
> ![](/resource/jvm1.webp)
> + Первоначально загружается только класс *JvmComprehension*, как только код этого класса обращается к какому-то другому классу (любым способом: вызовом конструктора, обращением к статическому методу или полю) происходит следующий набор операций:  
>> 1. Виртуальная машина проверяет, загружен ли класс или нет, всякий раз, когда он сталкивается с классом.
>> 2. В случае, когда класс загружен, JVM продолжает выполнение класса, но когда класс не загружен, JVM просит подсистему ClassLoader загрузить этот конкретный класс. После этого подсистема передает управление Application ClassLoader.
>> 3. Затем Application делегирует запрос Platform, которое затем передает запрос Bootstrap. Теперь Bootstrap ищет в пути Bootstrap classpath, чтобы проверить, доступен ли класс или нет. Если класс доступен, он загружается, в противном случае запрос снова передается в Platform.
>> 4. Platform проверяет класс в расширении classpath. Если класс доступен, он загружается, в противном случае запрос снова передается в Application.
>> 5. Наконец, Application ищет класс в пути к классам приложения. Если класс доступен, то загружается, иначе вы увидите исключение ClassNotFoundException.
> + По мере выполнения кода, загружаются всё новые и новые классы. Ни один класс не загружается до тех пор, пока в нем не возникнет реальная потребность. Такое поведение заложено в стандартный системный загрузчик.
>> После загрузки класса начинается этап линковки, который делится на три части.
>> 1. Верификация байт-кода. Это статический анализ кода, выполняется один раз для класса. Система проверяет, нет ли ошибок в байт-коде. Например, проверяет корректность инструкций, переполнение стека и совместимость типов переменных.
>> 2. Выделение памяти под статические поля и их инициализация.
>> 3. Разрешение символьных ссылок — JVM подставляет ссылки на другие классы, методы и поля. В большинстве случаев это происходит лениво, то есть при первом обращении к классу.

## Области памяти 
### Cтэк (и его фреймы), хип, метаспейс
> ![](/resource/Memory.jpeg)  
> public class JvmComprehension {
> 
>     public static void main(String[] args) { // создать в стеке фрейм1
>         int i = 1;                      // 1 взять число 1 и положить его во фрейм1
>         Object o = new Object();        // 2 создать обьект в кучи и положить ссылку на обьект в фрейм1
>         Integer ii = 2;                 // 3 создать объект в кучи и положить ссылку на объект в фрейм1
>         printAll(o, i, ii);             // 4 создать в стеке фрейм2
>         System.out.println("finished"); // 7 создать фрейм4, создать объект в пуле строк "finished" и положить ссылку на объект в фрейм4.
>     }
> 
>     private static void printAll(Object o, int i, Integer ii) {
>         Integer uselessVar = 700;                   // 5 создать объект в куче и положить ссылку на объект в фрейм2
>         System.out.println(o.toString() + i + ii);  // 6 создать фрейм3, создать объект в пуле строк "java.lang.Object@27716f412" (для этого вызывается множество методов внутри метода println), положить ссылку на объект в фрейм3
>     }
>}
## Сборщик мусора 
> ![](/resource/garbageCollector.png)  
> Для сборки мусора используется алгоритм пометок(Mark & Sweep):  
> 1. Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .  
> 2. Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.  
> 3. Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.  
> Алгорит сборки мусора выглядит следующим образом:
> 1. Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые.  
> 2. Когда область Eden заполняется, происходит минорная сборка мусора (Minor GC). Minor GC — это процесс, при котором операции mark и sweep выполняются для young generation (молодого поколения).  
> 3. После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью удаляются.
> 4. По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты перемещаются в область S1, и их возраст увеличивается (отметка о том, что они пережили сборку мусора).
> 5. При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются.
> 6. Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old.
> 7. Major GC. При Major GC этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с Minor GC, поскольку старое поколение в основном состоит из живых объектов.

> public class JvmComprehension {
> 
>     public static void main(String[] args) { 
>         int i = 1;                      // 1 создается переменная в стеке пока будет выполняться метод main.
>         Object o = new Object();        // 2 создается в Eden
>         Integer ii = 2;                 // 3 создается в Eden
>         printAll(o, i, ii);             // 4 
>         System.out.println("finished"); // 7 после окончания работы метода println(), класс JvmComprehension помечается как мертвый  и зачищается при следующей зачистки мертвых объектов
>     }
> 
>     private static void printAll(Object o, int i, Integer ii) {
>         Integer uselessVar = 700;                   // 5 создается в Eden
>         System.out.println(o.toString() + i + ii);  // 6 после окончания работы метода println(), метод printAll помечается как мертвый и зачищается при следующей зачистки мертвых объектов
>     }
>}

> Источники:  
> https://java-blog.ru/osnovy/classloader-java  
> https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ClassLoader.html  
> https://thistechnologylife.com/java-classloader/  
> https://habr.com/ru/company/otus/blog/553996/

